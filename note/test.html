<script>
(async () => {
  const RSS = "/note/feed.xml";

  // 便利関数
  const abs = (u)=>{
    if (!u) return "";
    if (/^https?:\/\//i.test(u)) return u;
    if (u.startsWith("//")) return "https:" + u;
    if (u.startsWith("/"))  return "https://note.com" + u;
    return u;
  };
  const FALLBACK = "https://assets.st-note.com/production/uploads/images/default/ogp.png";
  const prox  = (u)=> u ? `https://images.weserv.nl/?url=${encodeURIComponent(u.replace(/^https?:\/\//,''))}&output=jpg` : "";

  // HTML文字列 -> 最初の<img>src 抜き
  const firstImgFromHTML = (html)=>{
    if (!html) return "";
    const decoded = new DOMParser().parseFromString(html, "text/html").documentElement.textContent || html;
    const doc = new DOMParser().parseFromString(decoded, "text/html");
    const img = doc.querySelector("img");
    return img ? (img.getAttribute("src") || img.getAttribute("data-src") || img.getAttribute("data-original") || "") : "";
  };

  // RSSを読む
  const res = await fetch(RSS, {cache:"no-store"});
  if (!res.ok) throw new Error("mirror fetch failed: "+res.status);
  const xml = new DOMParser().parseFromString(await res.text(), "text/xml");

  const it  = xml.querySelector("item");            // ← ここで it を決める
  const title = it.querySelector("title")?.textContent ?? "";
  const link  = it.querySelector("link")?.textContent ?? "#";

  // 画像抽出（優先順: media:thumbnail → enclosure[url] → 本文<img>）
  const mediaNS = "http://search.yahoo.com/mrss/";
  let raw = "";

  // 1) media:thumbnail（NS対応）
  const thumbs = it.getElementsByTagNameNS(mediaNS, "thumbnail");
  if (thumbs && thumbs.length) {
    const n = thumbs[0];
    raw = (n.getAttribute("url") || n.textContent || "").trim();
  }

  // 2) enclosure の url
  if (!raw) {
    const enc = it.querySelector("enclosure[url]");
    if (enc) raw = enc.getAttribute("url") || "";
  }

  // 3) content:encoded / description から最初の<img>
  if (!raw) {
    const html = it.querySelector("content\\:encoded")?.textContent
              || it.querySelector("description")?.textContent || "";
    raw = firstImgFromHTML(html);
  }

  // 絶対化 + 最終フォールバック
  const imgRaw = abs(raw || FALLBACK);

  // 表示（weserv経由をまず試す）
  const el = document.getElementById("card");
  const srcProx = prox(imgRaw);

  el.innerHTML = `
    <a href="${link}" target="_blank" rel="noopener" style="display:block;color:inherit;text-decoration:none">
      <div style="aspect-ratio:16/9;background:#eee;border-radius:12px;overflow:hidden;box-shadow:0 4px 16px rgba(0,0,0,.08)">
        <img id="ph" alt="${title}" loading="eager"
             style="width:100%;height:100%;object-fit:cover;display:block">
      </div>
      <div style="padding:12px 14px"><strong>${title}</strong></div>
      <div style="font-size:12px;color:#666;padding:0 14px 12px">
        raw: ${imgRaw}<br>proxied: ${srcProx}
      </div>
    </a>
  `;

  // フォールバック連鎖（weserv → raw 直 → weserv(FALLBACK) → FALLBACK）
  const ph = document.getElementById("ph");
  const candidates = [
    srcProx,
    imgRaw,
    prox(FALLBACK),
    FALLBACK
  ].filter(Boolean);

  let i = 0;
  const tryNext = () => {
    if (i >= candidates.length) return;
    ph.src = candidates[i++];
  };
  ph.addEventListener("error", tryNext);
  tryNext(); // 最初の候補から開始
})();
</script>
